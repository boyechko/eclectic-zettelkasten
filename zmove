#!/usr/bin/env ruby
# coding: utf-8
# Move the given zettel to a new location

# FIXME:
# - the path now must be absolute; allow relative path

require 'clamp'
require 'pathname'
require 'yaml'
require_relative 'zettel'

ZETTEL_DIR = Zettelkasten.root
EXT = Zettelkasten.ext

Clamp do
  parameter "OLD", "zettel to move (numerus currens or filepath)"
  parameter "NEW", "where to move the zettel (numerus currens or filepath)"

  # Reads the STRING as YAML metadata from the Zettel, returning a hash of values
  def from_yaml(string)
    hash = {}
    string.split("\n").each do |line|
      key, val = line.split(':').map { |x| x.strip }

      if val.include?(",")
        # If the value is a list (contains commas), make it an array, and either
        # add it do existing array or create a new one.
        vals = val.split("\s*,\s*")
        if hash[key].is_a?(Array)
          hash[key].concat(vals)
        else
          hash[key] = vals
        end
      else
        # If the value is scalar, just ensure that we're adding to rather than
        # overwriting an existing hash entry.
        if hash[key]
          if hash[key].is_a?(Array)
            hash[key].push(val)
          else
            hash[key] = [ hash[key], val ]
          end
        else
          hash[key] = val
        end
      end
    end
    return hash
  end

  # Generates a YAML block as a string, using inline sequence style
  def to_yaml(hash)
    result = ""
    hash.each do |key, val|
      if val.is_a?(Array)
        result += "#{key}: #{val.join(' ')}\n"
      else
        result += "#{key}: #{val}\n"
      end
    end
    return result
  end

  # Returns the wiki link target for the given Zettel file
  def link_target(file_path)
    parent = File.dirname(file_path).split("/").last
    zettel = File.basename(file_path, EXT)
    if parent =~ /(limbo|tech|personal|writing)/
      return "#{1}:#{zettel}"
    else
      return zettel
    end
  end

  def execute
    # Figure out the full path for OLD
    if old =~ /^\d{3}[a-z-]*$/
      old_path = Numerus.new(old).path
    elsif File.exists?(old)
      old_path = File.expand_path(old)
      old = File.basename(old_path, EXT)
    else
      puts "zmove: Unable to figure out what file '#{old}' is"
      exit(1)
    end
    #puts "TESTING #{Pathname.new(old_path)}, #{Pathname.new(Zettelkasten.root)}"
    old_relv = Pathname.new(old_path).relative_path_from(Pathname.new(Zettelkasten.root)).to_s

    # Figure out the full path for NEW
    if new =~ /^\d{3}[a-z-]*$/
        new_path = Numerus.new(new).path
    elsif new =~ /#{EXT}$/
      # FIXME: A hack, assumes if a file has an extension, treat it as fully
      # qualified.
      new_path = File.expand_path(new)
      new = File.basename(new_path, EXT)
    else
      puts "zmove: Unable to figure out what file '#{new}' is"
      exit(1)
    end
    new_relv = Pathname.new(new_path).relative_path_from(Pathname.new(Zettelkasten.root)).to_s

    # Give user chance to interrupt
    puts "zmove: Press [Enter] to move #{old_relv} to #{new_relv}..."
    STDIN.gets

    # Move the files themselves
    Dir.chdir(Zettelkasten.root)
    system("hg mv #{old_relv} #{new_relv}")
    if $?.exitstatus != 0
      puts "zmove: Mercurial could not move the file; aborting"
      exit(1)
    end

    # Change the title, add oldname, and then retouch to original modtime
    metadata = from_yaml(File.read(new_path).split("\n\n", 2)[0])
    if metadata.is_a?(Hash)
      metadata['title'].gsub("ยง#{old}.", "ยง#{new}.") if metadata['title']
      if metadata['oldname'].is_a?(Array)
        metadata['oldname'].push(old)
      else
        metadata['oldname'] = [ old ]
      end
    else
      puts "zmove: Cannot parse the file's metadata; leaving file unchanged"
      exit(0)
    end
    system("zfix #{new_path}")

    # Find and replace all wiki links to $old with $new
    puts "zmove: Find and replace all wiki links to #{old} with #{new}..."
    links = `zlinksto #{old}`
    puts links + "\nPress [Enter] to replace the links..."
    STDIN.gets
    IO.popen("zchangelinks #{old} #{new}") do |subproc|
      subproc.write(links)
      subproc.close_write
      puts subproc.read
    end
  end
end
