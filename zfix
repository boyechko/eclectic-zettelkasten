#!/usr/bin/env ruby
# Fix the timestamp of the given zettel

require 'clamp'
require 'time'

HG_TIMESTAMP = File.expand_path("~/Dropbox/Doc/zettel/.hgtimestamp")
EXT = ".txt"

Clamp do
  parameter "FILE", "zettel file for which to fix the timestamp",
            :attribute_name => :file
  option ["-o", "--oldname"], "SLUG", "the old name for the zettel",
         :attribute_name => :oldname
  option ["-f", "--fromname"], :flag, "parse the time from filename",
         :attribute_name => :fromname

  # Get the modified or created date from the Zettel, returning a Time object
  def zettel_last_modified(file)
    if `egrep '^modified:' #{file}` =~ /^modified:\s+(\d{4}-\d{2}-\d{2})/ or
      `egrep '^created:' #{file}` =~ /^created:\s+(\d{4}-\d{2}-\d{2})/
      return Time.parse($1)
    end
  end

  # Returns true if both times have the same date
  def same_date?(time1, time2)
    time1.year == time2.year and time1.yday == time2.yday
  end

  # Print the status message
  def p_status(file, message)
    puts "zfix: #{File.basename(file)}: " + message
  end

  # Retouch the given file with the new mtime
  def retouch(file, new_mtime)
    return system("touch", "-d", "@#{new_mtime.to_f}", file)
  end

  # Returns the .hgtimestamp for file as a Time object
  def hg_timestamp(file)
    File.open(HG_TIMESTAMP) do |ts|
      return ts.grep(/["\/]#{Regexp.quote(File.basename(file))}/).last
    end
  end

  # Script point of entry
  def execute
    # Only fix modified time if it's different from the date in the Zettel
    if same_date?(File.mtime(file), zettel_last_modified(file))
      p_status(file, "File's modification date and modified line match; skipping")
      exit(0)
    elsif fromname? && basename =~ /^[0-9]{8}T[0-9]{4}\./
      # Get the timestamp from filename, and the filename is a datename
      p_status(file, "Using filename date: $1")
    elsif fromname?
      # Get the timestamp from filename, but it's not a datename
      p_status(file, "Can't parse filename to get time from it")
      exit(1)
    else
      # Get the timestamp for file or its oldname from .hgtimestamp
      #
      # sample line from .hgtimestamp:
      #       "tech/363-d.txt": {"timestamp": 1436311993.0},

      # Try to get timestamp for the file OR for the supplied oldname (to_s is
      # needed in case oldname is nil) OR for one of the oldname lines in the
      # file itself.
      if (timestamp = hg_timestamp(file) ||
                     hg_timestamp(oldname.to_s + EXT) ||
                     timestamp = File.open(file).grep(/oldname/).reverse
                                 .find { |s|
           if s =~ /^oldname: (\d{8}T\d{4})/
             hg_timestamp($1 + EXT)
           end }) &&
         (timestamp =~ /([0-9]{10}\.[0-9]+)},*$/)

        # Everything checks out, so retouch with slightly increased time so that
        # mercurial registers that there is a change
        old_time = Time.at($1.to_i)
        new_time = old_time + 1
        p old_time, new_time

        if retouch(file, new_time)
          p_status(file, "Retouched to #{new_time.strftime("%F %R")} "\
                         "(was #{old_time.strftime("%R")})")
        end
      else
        p_status(file, "Could not get the timestamp")
        exit(1)
      end
    end
  end
end
